<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Network Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &#10;    &lt;!-- Network Features --&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.wifi&quot; android:required=&quot;false&quot; /&gt;&#10;    &#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        android:theme=&quot;@style/Theme.ChatBluetooth&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ServerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;TCP Server&quot;&#10;            android:parentActivityName=&quot;.MainActivity&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ClientActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;TCP Client&quot;&#10;            android:parentActivityName=&quot;.MainActivity&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Network Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;    &#10;    &lt;!-- Network Features --&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.wifi&quot; android:required=&quot;false&quot; /&gt;&#10;    &#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        android:theme=&quot;@style/Theme.ChatBluetooth&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ServerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;TCP Server&quot;&#10;            android:parentActivityName=&quot;.MainActivity&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ClientActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;TCP Client&quot;&#10;            android:parentActivityName=&quot;.MainActivity&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ChatAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ChatAdapter.kt" />
              <option name="originalContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.view.LayoutInflater&#10;import android.view.ViewGroup&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.bluetoothchat.with.ai.databinding.ItemMessageReceivedBinding&#10;import com.bluetoothchat.with.ai.databinding.ItemMessageSentBinding&#10;&#10;class ChatAdapter : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {&#10;    &#10;    private val messages: MutableList&lt;ChatMessage&gt; = mutableListOf()&#10;    &#10;    companion object {&#10;        private const val VIEW_TYPE_SENT = 1&#10;        private const val VIEW_TYPE_RECEIVED = 2&#10;    }&#10;    &#10;    fun addMessage(message: ChatMessage) {&#10;        messages.add(message)&#10;        notifyItemInserted(messages.size - 1)&#10;    }&#10;    &#10;    override fun getItemViewType(position: Int): Int {&#10;        return if (messages[position].isSent) VIEW_TYPE_SENT else VIEW_TYPE_RECEIVED&#10;    }&#10;    &#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {&#10;        return when (viewType) {&#10;            VIEW_TYPE_SENT -&gt; {&#10;                val binding = ItemMessageSentBinding.inflate(&#10;                    LayoutInflater.from(parent.context),&#10;                    parent,&#10;                    false&#10;                )&#10;                SentMessageViewHolder(binding)&#10;            }&#10;            VIEW_TYPE_RECEIVED -&gt; {&#10;                val binding = ItemMessageReceivedBinding.inflate(&#10;                    LayoutInflater.from(parent.context),&#10;                    parent,&#10;                    false&#10;                )&#10;                ReceivedMessageViewHolder(binding)&#10;            }&#10;            else -&gt; throw IllegalArgumentException(&quot;Invalid view type&quot;)&#10;        }&#10;    }&#10;    &#10;    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {&#10;        val message = messages[position]&#10;        when (holder) {&#10;            is SentMessageViewHolder -&gt; holder.bind(message)&#10;            is ReceivedMessageViewHolder -&gt; holder.bind(message)&#10;        }&#10;    }&#10;    &#10;    override fun getItemCount(): Int = messages.size&#10;    &#10;    class SentMessageViewHolder(private val binding: ItemMessageSentBinding) :&#10;        RecyclerView.ViewHolder(binding.root) {&#10;&#10;        fun bind(message: ChatMessage) {&#10;            binding.messageText.text = message.text&#10;            binding.timeText.text = message.timestamp&#10;        }&#10;    }&#10;    &#10;    class ReceivedMessageViewHolder(private val binding: ItemMessageReceivedBinding) :&#10;        RecyclerView.ViewHolder(binding.root) {&#10;&#10;        fun bind(message: ChatMessage) {&#10;            binding.messageText.text = message.text&#10;            binding.senderText.text = message.senderName&#10;            binding.timeText.text = message.timestamp&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.view.LayoutInflater&#10;import android.view.ViewGroup&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.bluetoothchat.with.ai.databinding.ItemMessageReceivedBinding&#10;import com.bluetoothchat.with.ai.databinding.ItemMessageSentBinding&#10;&#10;class ChatAdapter : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {&#10;    &#10;    private val messages: MutableList&lt;ChatMessage&gt; = mutableListOf()&#10;    &#10;    companion object {&#10;        private const val VIEW_TYPE_SENT = 1&#10;        private const val VIEW_TYPE_RECEIVED = 2&#10;    }&#10;    &#10;    fun addMessage(message: ChatMessage) {&#10;        messages.add(message)&#10;        notifyItemInserted(messages.size - 1)&#10;    }&#10;    &#10;    override fun getItemViewType(position: Int): Int {&#10;        return if (messages[position].isSent) VIEW_TYPE_SENT else VIEW_TYPE_RECEIVED&#10;    }&#10;    &#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {&#10;        return when (viewType) {&#10;            VIEW_TYPE_SENT -&gt; {&#10;                val binding = ItemMessageSentBinding.inflate(&#10;                    LayoutInflater.from(parent.context),&#10;                    parent,&#10;                    false&#10;                )&#10;                SentMessageViewHolder(binding)&#10;            }&#10;            VIEW_TYPE_RECEIVED -&gt; {&#10;                val binding = ItemMessageReceivedBinding.inflate(&#10;                    LayoutInflater.from(parent.context),&#10;                    parent,&#10;                    false&#10;                )&#10;                ReceivedMessageViewHolder(binding)&#10;            }&#10;            else -&gt; throw IllegalArgumentException(&quot;Invalid view type&quot;)&#10;        }&#10;    }&#10;    &#10;    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {&#10;        val message = messages[position]&#10;        when (holder) {&#10;            is SentMessageViewHolder -&gt; holder.bind(message)&#10;            is ReceivedMessageViewHolder -&gt; holder.bind(message)&#10;        }&#10;    }&#10;    &#10;    override fun getItemCount(): Int = messages.size&#10;    &#10;    class SentMessageViewHolder(private val binding: ItemMessageSentBinding) :&#10;        RecyclerView.ViewHolder(binding.root) {&#10;&#10;        fun bind(message: ChatMessage) {&#10;            binding.messageText.text = message.text&#10;            binding.timeText.text = message.timestamp&#10;        }&#10;    }&#10;    &#10;    class ReceivedMessageViewHolder(private val binding: ItemMessageReceivedBinding) :&#10;        RecyclerView.ViewHolder(binding.root) {&#10;&#10;        fun bind(message: ChatMessage) {&#10;            binding.messageText.text = message.text&#10;            binding.senderText.text = message.sender&#10;            binding.timeText.text = message.timestamp&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ChatFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ChatFragment.kt" />
              <option name="originalContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.fragment.app.Fragment&#10;import com.bluetoothchat.with.ai.databinding.FragmentChatBinding&#10;import com.google.android.material.snackbar.Snackbar&#10;&#10;class ChatFragment : Fragment() {&#10;    &#10;    private var _binding: FragmentChatBinding? = null&#10;    private val binding get() = _binding!!&#10;    &#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private lateinit var networkService: NetworkService&#10;    &#10;    private val imagePickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        uri?.let {&#10;            // Handle image selection&#10;            Snackbar.make(binding.root, &quot;Image selected: ${uri.lastPathSegment}&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentChatBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;    &#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        &#10;        setupNetworkService()&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;        setupMessageInput()&#10;        updateConnectionStatus()&#10;    }&#10;    &#10;    private fun setupNetworkService() {&#10;        val mainActivity = activity as? MainActivity&#10;        networkService = mainActivity?.getNetworkService() ?: NetworkService(requireContext())&#10;        &#10;        networkService.setOnMessageReceived { message, senderIp -&gt;&#10;            requireActivity().runOnUiThread {&#10;                val senderName = if (senderIp == &quot;SERVER&quot;) &quot;Server&quot; else &quot;Device $senderIp&quot;&#10;                chatAdapter.addMessage(ChatMessage(message, false, senderName))&#10;            }&#10;        }&#10;        &#10;        networkService.setOnConnectionStatusChanged { isConnected -&gt;&#10;            requireActivity().runOnUiThread {&#10;                updateConnectionStatus()&#10;                if (isConnected) {&#10;                    Snackbar.make(binding.root, &quot;Connected to chat network&quot;, Snackbar.LENGTH_SHORT).show()&#10;                } else {&#10;                    Snackbar.make(binding.root, &quot;Disconnected from chat network&quot;, Snackbar.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun setupToolbar() {&#10;        binding.topAppBar.setNavigationOnClickListener {&#10;            // Navigate back to connections&#10;            Snackbar.make(binding.root, &quot;Back to connections&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.adapter = chatAdapter&#10;        &#10;        // Add welcome message&#10;        chatAdapter.addMessage(ChatMessage(&quot;Welcome to LAN Chat! Connect to a device to start chatting.&quot;, false, &quot;System&quot;))&#10;    }&#10;    &#10;    private fun setupClickListeners() {&#10;        binding.attachButton.setOnClickListener {&#10;            openImagePicker()&#10;        }&#10;        &#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;    }&#10;    &#10;    private fun setupMessageInput() {&#10;        binding.messageInputEditText.addTextChangedListener(object : android.text.TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}&#10;            override fun afterTextChanged(s: android.text.Editable?) {&#10;                binding.sendButton.isEnabled = !s.isNullOrBlank() &amp;&amp; networkService.isConnected()&#10;            }&#10;        })&#10;    }&#10;    &#10;    private fun updateConnectionStatus() {&#10;        val isConnected = networkService.isConnected()&#10;        binding.sendButton.isEnabled = isConnected &amp;&amp; !binding.messageInputEditText.text.isNullOrBlank()&#10;        &#10;        if (isConnected) {&#10;            binding.connectionStatus.text = &quot;Connected&quot;&#10;            binding.connectionStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            binding.connectionStatus.text = &quot;Disconnected&quot;&#10;            binding.connectionStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;    }&#10;    &#10;    private fun openImagePicker() {&#10;        imagePickerLauncher.launch(&quot;image/*&quot;)&#10;    }&#10;    &#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInputEditText.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; networkService.isConnected()) {&#10;            // Add message to local chat&#10;            chatAdapter.addMessage(ChatMessage(messageText, true, &quot;You&quot;))&#10;            &#10;            // Send message through network&#10;            networkService.sendMessage(messageText)&#10;            &#10;            // Clear input&#10;            binding.messageInputEditText.text?.clear()&#10;        } else if (!networkService.isConnected()) {&#10;            Snackbar.make(binding.root, &quot;Not connected to any device&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}&#10;&#10;data class ChatMessage(&#10;    val text: String,&#10;    val isSent: Boolean,&#10;    val sender: String = &quot;&quot;&#10;) " />
              <option name="updatedContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.fragment.app.Fragment&#10;import com.bluetoothchat.with.ai.databinding.FragmentChatBinding&#10;import com.google.android.material.snackbar.Snackbar&#10;&#10;class ChatFragment : Fragment() {&#10;    &#10;    private var _binding: FragmentChatBinding? = null&#10;    private val binding get() = _binding!!&#10;    &#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private lateinit var networkService: NetworkService&#10;    &#10;    private val imagePickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        uri?.let {&#10;            // Handle image selection&#10;            Snackbar.make(binding.root, &quot;Image selected: ${uri.lastPathSegment}&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentChatBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;    &#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        &#10;        setupNetworkService()&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;        setupMessageInput()&#10;        updateConnectionStatus()&#10;    }&#10;    &#10;    private fun setupNetworkService() {&#10;        val mainActivity = activity as? MainActivity&#10;        networkService = mainActivity?.getNetworkService() ?: NetworkService(requireContext())&#10;        &#10;        networkService.setOnMessageReceived { message, senderIp -&gt;&#10;            requireActivity().runOnUiThread {&#10;                val senderName = if (senderIp == &quot;SERVER&quot;) &quot;Server&quot; else &quot;Device $senderIp&quot;&#10;                chatAdapter.addMessage(ChatMessage(message, false, senderName))&#10;            }&#10;        }&#10;        &#10;        networkService.setOnConnectionStatusChanged { isConnected -&gt;&#10;            requireActivity().runOnUiThread {&#10;                updateConnectionStatus()&#10;                if (isConnected) {&#10;                    Snackbar.make(binding.root, &quot;Connected to chat network&quot;, Snackbar.LENGTH_SHORT).show()&#10;                } else {&#10;                    Snackbar.make(binding.root, &quot;Disconnected from chat network&quot;, Snackbar.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun setupToolbar() {&#10;        binding.topAppBar.setNavigationOnClickListener {&#10;            // Navigate back to connections&#10;            Snackbar.make(binding.root, &quot;Back to connections&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.adapter = chatAdapter&#10;        &#10;        // Add welcome message&#10;        chatAdapter.addMessage(ChatMessage(&quot;Welcome to LAN Chat! Connect to a device to start chatting.&quot;, false, &quot;System&quot;))&#10;    }&#10;    &#10;    private fun setupClickListeners() {&#10;        binding.attachButton.setOnClickListener {&#10;            openImagePicker()&#10;        }&#10;        &#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;    }&#10;    &#10;    private fun setupMessageInput() {&#10;        binding.messageInputEditText.addTextChangedListener(object : android.text.TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}&#10;            override fun afterTextChanged(s: android.text.Editable?) {&#10;                binding.sendButton.isEnabled = !s.isNullOrBlank() &amp;&amp; networkService.isConnected()&#10;            }&#10;        })&#10;    }&#10;    &#10;    private fun updateConnectionStatus() {&#10;        val isConnected = networkService.isConnected()&#10;        binding.sendButton.isEnabled = isConnected &amp;&amp; !binding.messageInputEditText.text.isNullOrBlank()&#10;        &#10;        if (isConnected) {&#10;            binding.connectionStatus.text = &quot;Connected&quot;&#10;            binding.connectionStatus.setTextColor(resources.getColor(android.R.color.holo_green_dark, null))&#10;        } else {&#10;            binding.connectionStatus.text = &quot;Disconnected&quot;&#10;            binding.connectionStatus.setTextColor(resources.getColor(android.R.color.holo_red_dark, null))&#10;        }&#10;    }&#10;    &#10;    private fun openImagePicker() {&#10;        imagePickerLauncher.launch(&quot;image/*&quot;)&#10;    }&#10;    &#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInputEditText.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; networkService.isConnected()) {&#10;            // Add message to local chat&#10;            chatAdapter.addMessage(ChatMessage(messageText, true, &quot;You&quot;))&#10;            &#10;            // Send message through network&#10;            networkService.sendMessage(messageText)&#10;            &#10;            // Clear input&#10;            binding.messageInputEditText.text?.clear()&#10;        } else if (!networkService.isConnected()) {&#10;            Snackbar.make(binding.root, &quot;Not connected to any device&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ChatMessage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ChatMessage.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.bluetoothchat.with.ai&#10;&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;data class ChatMessage(&#10;    val text: String,&#10;    val isSent: Boolean,&#10;    val sender: String,&#10;    val timestamp: String = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault()).format(Date())&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ClientActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ClientActivity.kt" />
              <option name="originalContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.bluetoothchat.with.ai.databinding.ActivityClientBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ClientActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityClientBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var socket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isConnected = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ClientActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityClientBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Client&quot;&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ClientActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn hướng dẫn&#10;        addSystemMessage(&quot;Enter server IP address and tap Connect&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.connectButton.setOnClickListener {&#10;            val serverIp = binding.serverIpInput.text.toString().trim()&#10;            if (serverIp.isNotEmpty()) {&#10;                if (!isConnected) {&#10;                    connectToServer(serverIp)&#10;                } else {&#10;                    disconnect()&#10;                }&#10;            } else {&#10;                Toast.makeText(this, &quot;Please enter server IP address&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, _, _ -&gt;&#10;            sendMessage()&#10;            true&#10;        }&#10;    }&#10;&#10;    private fun connectToServer(serverIp: String) {&#10;        binding.connectButton.isEnabled = false&#10;        binding.serverIpInput.isEnabled = false&#10;&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Connecting to server: $serverIp:$PORT&quot;)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connecting to $serverIp:$PORT...&quot;)&#10;                }&#10;&#10;                socket = Socket()&#10;                socket?.connect(InetSocketAddress(serverIp, PORT), 10000) // 10 second timeout&#10;&#10;                Log.d(TAG, &quot;Connected to server&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connected to server!&quot;)&#10;                    isConnected = true&#10;                    binding.connectButton.text = &quot;Disconnect&quot;&#10;                    binding.connectButton.isEnabled = true&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                    binding.toolbar.subtitle = &quot;Connected to $serverIp:$PORT&quot;&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(socket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(socket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ server&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Connection error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connection failed: ${e.message}&quot;)&#10;                    Toast.makeText(this@ClientActivity, &quot;Connection failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    resetConnectionUI()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isConnected &amp;&amp; socket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Server&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Server đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    if (isConnected) {&#10;                        addSystemMessage(&quot;Disconnected from server&quot;)&#10;                        resetConnectionUI()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null &amp;&amp; isConnected) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Client&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ClientActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun disconnect() {&#10;        thread {&#10;            cleanup()&#10;            runOnUiThread {&#10;                addSystemMessage(&quot;Disconnected from server&quot;)&#10;                resetConnectionUI()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetConnectionUI() {&#10;        isConnected = false&#10;        binding.connectButton.text = &quot;Connect&quot;&#10;        binding.connectButton.isEnabled = true&#10;        binding.serverIpInput.isEnabled = true&#10;        binding.sendButton.isEnabled = false&#10;        binding.messageInput.isEnabled = false&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isConnected = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            socket?.close()&#10;            Log.d(TAG, &quot;Client cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.bluetoothchat.with.ai.databinding.ActivityClientBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ClientActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityClientBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var socket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isConnected = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ClientActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityClientBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Client&quot;&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ClientActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn hướng dẫn&#10;        addSystemMessage(&quot;Enter server IP address and tap Connect&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.connectButton.setOnClickListener {&#10;            val serverIp = binding.serverIpInput.text.toString().trim()&#10;            if (serverIp.isNotEmpty()) {&#10;                if (!isConnected) {&#10;                    connectToServer(serverIp)&#10;                } else {&#10;                    disconnect()&#10;                }&#10;            } else {&#10;                Toast.makeText(this, &quot;Please enter server IP address&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {&#10;                sendMessage()&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun connectToServer(serverIp: String) {&#10;        binding.connectButton.isEnabled = false&#10;        binding.serverIpInput.isEnabled = false&#10;&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Connecting to server: $serverIp:$PORT&quot;)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connecting to $serverIp:$PORT...&quot;)&#10;                }&#10;&#10;                socket = Socket()&#10;                socket?.connect(InetSocketAddress(serverIp, PORT), 10000) // 10 second timeout&#10;&#10;                Log.d(TAG, &quot;Connected to server&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connected to server!&quot;)&#10;                    isConnected = true&#10;                    binding.connectButton.text = &quot;Disconnect&quot;&#10;                    binding.connectButton.isEnabled = true&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                    binding.toolbar.subtitle = &quot;Connected to $serverIp:$PORT&quot;&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(socket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(socket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ server&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Connection error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connection failed: ${e.message}&quot;)&#10;                    Toast.makeText(this@ClientActivity, &quot;Connection failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    resetConnectionUI()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isConnected &amp;&amp; socket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Server&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Server đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    if (isConnected) {&#10;                        addSystemMessage(&quot;Disconnected from server&quot;)&#10;                        resetConnectionUI()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null &amp;&amp; isConnected) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Client&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ClientActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun disconnect() {&#10;        thread {&#10;            cleanup()&#10;            runOnUiThread {&#10;                addSystemMessage(&quot;Disconnected from server&quot;)&#10;                resetConnectionUI()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetConnectionUI() {&#10;        isConnected = false&#10;        binding.connectButton.text = &quot;Connect&quot;&#10;        binding.connectButton.isEnabled = true&#10;        binding.serverIpInput.isEnabled = true&#10;        binding.sendButton.isEnabled = false&#10;        binding.messageInput.isEnabled = false&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isConnected = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            socket?.close()&#10;            Log.d(TAG, &quot;Client cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/MainActivity.kt" />
              <option name="originalContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.os.Bundle&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import com.bluetoothchat.with.ai.databinding.ActivityMainBinding&#10;import com.google.android.material.snackbar.Snackbar&#10;import java.net.Inet4Address&#10;import java.net.NetworkInterface&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    &#10;    private lateinit var binding: ActivityMainBinding&#10;    private lateinit var networkService: NetworkService&#10;&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (allGranted) {&#10;            Snackbar.make(binding.root, &quot;All permissions granted&quot;, Snackbar.LENGTH_SHORT).show()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Some permissions are required for network communication&quot;, Snackbar.LENGTH_LONG).show()&#10;        }&#10;    }&#10;    &#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;        &#10;        setupNetworkService()&#10;        requestPermissions()&#10;        setupClickListeners()&#10;    }&#10;    &#10;    private fun setupNetworkService() {&#10;        networkService = NetworkService(this)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.serverButton.setOnClickListener {&#10;            if (isNetworkAvailable()) {&#10;                startActivity(Intent(this, ServerActivity::class.java))&#10;            } else {&#10;                Snackbar.make(binding.root, &quot;Please connect to WiFi first&quot;, Snackbar.LENGTH_LONG).show()&#10;            }&#10;        }&#10;&#10;        binding.clientButton.setOnClickListener {&#10;            if (isNetworkAvailable()) {&#10;                startActivity(Intent(this, ClientActivity::class.java))&#10;            } else {&#10;                Snackbar.make(binding.root, &quot;Please connect to WiFi first&quot;, Snackbar.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestPermissions() {&#10;        val permissions = arrayOf(&#10;            Manifest.permission.INTERNET,&#10;            Manifest.permission.ACCESS_NETWORK_STATE,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        )&#10;        &#10;        val permissionsToRequest = permissions.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }.toTypedArray()&#10;        &#10;        if (permissionsToRequest.isNotEmpty()) {&#10;            permissionLauncher.launch(permissionsToRequest)&#10;        }&#10;    }&#10;    &#10;    fun isNetworkAvailable(): Boolean {&#10;        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;        val network = connectivityManager.activeNetwork ?: return false&#10;        val activeNetwork = connectivityManager.getNetworkCapabilities(network) ?: return false&#10;        &#10;        return activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||&#10;               activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)&#10;    }&#10;&#10;    fun getNetworkService(): NetworkService {&#10;        return networkService&#10;    }&#10;&#10;    fun getLocalIpAddress(): String {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            while (interfaces.hasMoreElements()) {&#10;                val networkInterface = interfaces.nextElement()&#10;                val addresses = networkInterface.inetAddresses&#10;                while (addresses.hasMoreElements()) {&#10;                    val address = addresses.nextElement()&#10;                    if (!address.isLoopbackAddress &amp;&amp; address is Inet4Address) {&#10;                        return address.hostAddress ?: &quot;Unknown&quot;&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;MainActivity&quot;, &quot;Error getting IP address: ${e.message}&quot;, e)&#10;        }&#10;        return &quot;Unknown&quot;&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        networkService.cleanup()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.os.Bundle&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import com.bluetoothchat.with.ai.databinding.ActivityMainBinding&#10;import com.google.android.material.snackbar.Snackbar&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    &#10;    private lateinit var binding: ActivityMainBinding&#10;    &#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (allGranted) {&#10;            Snackbar.make(binding.root, &quot;All permissions granted&quot;, Snackbar.LENGTH_SHORT).show()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Some permissions are required for network communication&quot;, Snackbar.LENGTH_LONG).show()&#10;        }&#10;    }&#10;    &#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;        &#10;        requestPermissions()&#10;        setupClickListeners()&#10;    }&#10;    &#10;    private fun setupClickListeners() {&#10;        binding.serverButton.setOnClickListener {&#10;            if (isNetworkAvailable()) {&#10;                startActivity(Intent(this, ServerActivity::class.java))&#10;            } else {&#10;                Snackbar.make(binding.root, &quot;Please connect to WiFi first&quot;, Snackbar.LENGTH_LONG).show()&#10;            }&#10;        }&#10;&#10;        binding.clientButton.setOnClickListener {&#10;            if (isNetworkAvailable()) {&#10;                startActivity(Intent(this, ClientActivity::class.java))&#10;            } else {&#10;                Snackbar.make(binding.root, &quot;Please connect to WiFi first&quot;, Snackbar.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestPermissions() {&#10;        val permissions = arrayOf(&#10;            Manifest.permission.INTERNET,&#10;            Manifest.permission.ACCESS_NETWORK_STATE,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        )&#10;        &#10;        val permissionsToRequest = permissions.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }.toTypedArray()&#10;        &#10;        if (permissionsToRequest.isNotEmpty()) {&#10;            permissionLauncher.launch(permissionsToRequest)&#10;        }&#10;    }&#10;    &#10;    private fun isNetworkAvailable(): Boolean {&#10;        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;        val network = connectivityManager.activeNetwork ?: return false&#10;        val activeNetwork = connectivityManager.getNetworkCapabilities(network) ?: return false&#10;        &#10;        return activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||&#10;               activeNetwork.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ServerActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/bluetoothchat/with/ai/ServerActivity.kt" />
              <option name="originalContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.bluetoothchat.with.ai.databinding.ActivityServerBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ServerActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityServerBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isRunning = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ServerActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityServerBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;        startServer()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Server&quot;&#10;        binding.toolbar.subtitle = &quot;Listening on port $PORT&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ServerActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn chào mừng&#10;        addSystemMessage(&quot;Server started on port $PORT&quot;)&#10;        addSystemMessage(&quot;Waiting for client connection...&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, _, _ -&gt;&#10;            sendMessage()&#10;            true&#10;        }&#10;    }&#10;&#10;    private fun startServer() {&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Starting server on port $PORT&quot;)&#10;                serverSocket = ServerSocket(PORT)&#10;                isRunning = true&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server listening on ${getLocalIpAddress()}:$PORT&quot;)&#10;                }&#10;&#10;                // Chờ client kết nối&#10;                clientSocket = serverSocket?.accept()&#10;&#10;                Log.d(TAG, &quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(clientSocket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(clientSocket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ client&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Server error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server error: ${e.message}&quot;)&#10;                    Toast.makeText(this@ServerActivity, &quot;Server error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isRunning &amp;&amp; clientSocket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Client&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Client đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client disconnected&quot;)&#10;                    binding.sendButton.isEnabled = false&#10;                    binding.messageInput.isEnabled = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Server&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ServerActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    private fun getLocalIpAddress(): String {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            while (interfaces.hasMoreElements()) {&#10;                val networkInterface = interfaces.nextElement()&#10;                val addresses = networkInterface.inetAddresses&#10;                while (addresses.hasMoreElements()) {&#10;                    val address = addresses.nextElement()&#10;                    if (!address.isLoopbackAddress &amp;&amp; address is Inet4Address) {&#10;                        return address.hostAddress ?: &quot;Unknown&quot;&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting IP address: ${e.message}&quot;, e)&#10;        }&#10;        return &quot;Unknown&quot;&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;            Log.d(TAG, &quot;Server cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.bluetoothchat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.inputmethod.EditorInfo&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.bluetoothchat.with.ai.databinding.ActivityServerBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ServerActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityServerBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isRunning = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ServerActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityServerBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;        startServer()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Server&quot;&#10;        binding.toolbar.subtitle = &quot;Listening on port $PORT&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ServerActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn chào mừng&#10;        addSystemMessage(&quot;Server started on port $PORT&quot;)&#10;        addSystemMessage(&quot;Waiting for client connection...&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {&#10;                sendMessage()&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startServer() {&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Starting server on port $PORT&quot;)&#10;                serverSocket = ServerSocket(PORT)&#10;                isRunning = true&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server listening on ${getLocalIpAddress()}:$PORT&quot;)&#10;                }&#10;&#10;                // Chờ client kết nối&#10;                clientSocket = serverSocket?.accept()&#10;&#10;                Log.d(TAG, &quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(clientSocket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(clientSocket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ client&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Server error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server error: ${e.message}&quot;)&#10;                    Toast.makeText(this@ServerActivity, &quot;Server error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isRunning &amp;&amp; clientSocket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Client&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Client đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client disconnected&quot;)&#10;                    binding.sendButton.isEnabled = false&#10;                    binding.messageInput.isEnabled = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Server&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ServerActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    private fun getLocalIpAddress(): String {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            while (interfaces.hasMoreElements()) {&#10;                val networkInterface = interfaces.nextElement()&#10;                val addresses = networkInterface.inetAddresses&#10;                while (addresses.hasMoreElements()) {&#10;                    val address = addresses.nextElement()&#10;                    if (!address.isLoopbackAddress &amp;&amp; address is Inet4Address) {&#10;                        return address.hostAddress ?: &quot;Unknown&quot;&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting IP address: ${e.message}&quot;, e)&#10;        }&#10;        return &quot;Unknown&quot;&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;            Log.d(TAG, &quot;Server cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/wifichat/with/ai/ClientActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/wifichat/with/ai/ClientActivity.kt" />
              <option name="originalContent" value="package com.wifichat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.wifichat.with.ai.databinding.ActivityClientBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ClientActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityClientBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var socket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isConnected = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ClientActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityClientBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Client&quot;&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ClientActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn hướng dẫn&#10;        addSystemMessage(&quot;Enter server IP address and tap Connect&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.connectButton.setOnClickListener {&#10;            val serverIp = binding.serverIpInput.text.toString().trim()&#10;            if (serverIp.isNotEmpty()) {&#10;                if (!isConnected) {&#10;                    connectToServer(serverIp)&#10;                } else {&#10;                    disconnect()&#10;                }&#10;            } else {&#10;                Toast.makeText(this, &quot;Please enter server IP address&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {&#10;                sendMessage()&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun connectToServer(serverIp: String) {&#10;        binding.connectButton.isEnabled = false&#10;        binding.serverIpInput.isEnabled = false&#10;&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Connecting to server: $serverIp:$PORT&quot;)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connecting to $serverIp:$PORT...&quot;)&#10;                }&#10;&#10;                socket = Socket()&#10;                socket?.connect(InetSocketAddress(serverIp, PORT), 10000) // 10 second timeout&#10;&#10;                Log.d(TAG, &quot;Connected to server&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connected to server!&quot;)&#10;                    isConnected = true&#10;                    binding.connectButton.text = &quot;Disconnect&quot;&#10;                    binding.connectButton.isEnabled = true&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                    binding.toolbar.subtitle = &quot;Connected to $serverIp:$PORT&quot;&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(socket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(socket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ server&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Connection error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connection failed: ${e.message}&quot;)&#10;                    Toast.makeText(this@ClientActivity, &quot;Connection failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    resetConnectionUI()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isConnected &amp;&amp; socket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Server&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Server đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    if (isConnected) {&#10;                        addSystemMessage(&quot;Disconnected from server&quot;)&#10;                        resetConnectionUI()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null &amp;&amp; isConnected) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Client&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ClientActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun disconnect() {&#10;        thread {&#10;            cleanup()&#10;            runOnUiThread {&#10;                addSystemMessage(&quot;Disconnected from server&quot;)&#10;                resetConnectionUI()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetConnectionUI() {&#10;        isConnected = false&#10;        binding.connectButton.text = &quot;Connect&quot;&#10;        binding.connectButton.isEnabled = true&#10;        binding.serverIpInput.isEnabled = true&#10;        binding.sendButton.isEnabled = false&#10;        binding.messageInput.isEnabled = false&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isConnected = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            socket?.close()&#10;            Log.d(TAG, &quot;Client cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.wifichat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.wifichat.with.ai.databinding.ActivityClientBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ClientActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityClientBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var socket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isConnected = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ClientActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityClientBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Client&quot;&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ClientActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn hướng dẫn&#10;        addSystemMessage(&quot;Enter server IP address and tap Connect&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.connectButton.setOnClickListener {&#10;            val serverIp = binding.serverIpInput.text.toString().trim()&#10;            if (serverIp.isNotEmpty()) {&#10;                if (!isConnected) {&#10;                    connectToServer(serverIp)&#10;                } else {&#10;                    disconnect()&#10;                }&#10;            } else {&#10;                Toast.makeText(this, &quot;Please enter server IP address&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {&#10;                sendMessage()&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun connectToServer(serverIp: String) {&#10;        binding.connectButton.isEnabled = false&#10;        binding.serverIpInput.isEnabled = false&#10;&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Connecting to server: $serverIp:$PORT&quot;)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connecting to $serverIp:$PORT...&quot;)&#10;                }&#10;&#10;                socket = Socket()&#10;                socket?.connect(InetSocketAddress(serverIp, PORT), 10000) // 10 second timeout&#10;                // Enable TCP keep-alive to maintain the connection&#10;                socket?.setKeepAlive(true)&#10;&#10;                Log.d(TAG, &quot;Connected to server&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connected to server!&quot;)&#10;                    isConnected = true&#10;                    binding.connectButton.text = &quot;Disconnect&quot;&#10;                    binding.connectButton.isEnabled = true&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                    binding.toolbar.subtitle = &quot;Connected to $serverIp:$PORT&quot;&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(socket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(socket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ server&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Connection error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Connection failed: ${e.message}&quot;)&#10;                    Toast.makeText(this@ClientActivity, &quot;Connection failed: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    resetConnectionUI()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isConnected &amp;&amp; socket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Server&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Server đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    if (isConnected) {&#10;                        addSystemMessage(&quot;Disconnected from server&quot;)&#10;                        resetConnectionUI()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null &amp;&amp; isConnected) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Client&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ClientActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun disconnect() {&#10;        thread {&#10;            cleanup()&#10;            runOnUiThread {&#10;                addSystemMessage(&quot;Disconnected from server&quot;)&#10;                resetConnectionUI()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetConnectionUI() {&#10;        isConnected = false&#10;        binding.connectButton.text = &quot;Connect&quot;&#10;        binding.connectButton.isEnabled = true&#10;        binding.serverIpInput.isEnabled = true&#10;        binding.sendButton.isEnabled = false&#10;        binding.messageInput.isEnabled = false&#10;        binding.toolbar.subtitle = &quot;Enter server IP and connect&quot;&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isConnected = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            socket?.close()&#10;            Log.d(TAG, &quot;Client cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/wifichat/with/ai/ServerActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/wifichat/with/ai/ServerActivity.kt" />
              <option name="originalContent" value="package com.wifichat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.inputmethod.EditorInfo&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.wifichat.with.ai.databinding.ActivityServerBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ServerActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityServerBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isRunning = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ServerActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityServerBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;        startServer()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Server&quot;&#10;        binding.toolbar.subtitle = &quot;Listening on port $PORT&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ServerActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn chào mừng&#10;        addSystemMessage(&quot;Server started on port $PORT&quot;)&#10;        addSystemMessage(&quot;Waiting for client connection...&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {&#10;                sendMessage()&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startServer() {&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Starting server on port $PORT&quot;)&#10;                serverSocket = ServerSocket(PORT)&#10;                isRunning = true&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server listening on ${getLocalIpAddress()}:$PORT&quot;)&#10;                }&#10;&#10;                // Chờ client kết nối&#10;                clientSocket = serverSocket?.accept()&#10;&#10;                Log.d(TAG, &quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(clientSocket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(clientSocket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ client&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Server error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server error: ${e.message}&quot;)&#10;                    Toast.makeText(this@ServerActivity, &quot;Server error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isRunning &amp;&amp; clientSocket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Client&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Client đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client disconnected&quot;)&#10;                    binding.sendButton.isEnabled = false&#10;                    binding.messageInput.isEnabled = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Server&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ServerActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    private fun getLocalIpAddress(): String {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            while (interfaces.hasMoreElements()) {&#10;                val networkInterface = interfaces.nextElement()&#10;                val addresses = networkInterface.inetAddresses&#10;                while (addresses.hasMoreElements()) {&#10;                    val address = addresses.nextElement()&#10;                    if (!address.isLoopbackAddress &amp;&amp; address is Inet4Address) {&#10;                        return address.hostAddress ?: &quot;Unknown&quot;&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting IP address: ${e.message}&quot;, e)&#10;        }&#10;        return &quot;Unknown&quot;&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;            Log.d(TAG, &quot;Server cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.wifichat.with.ai&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.inputmethod.EditorInfo&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.wifichat.with.ai.databinding.ActivityServerBinding&#10;import java.io.*&#10;import java.net.*&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.concurrent.thread&#10;&#10;class ServerActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityServerBinding&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var outputStream: PrintWriter? = null&#10;    private var inputStream: BufferedReader? = null&#10;    private var isRunning = false&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ServerActivity&quot;&#10;        private const val PORT = 5000&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityServerBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        setupToolbar()&#10;        setupChatAdapter()&#10;        setupClickListeners()&#10;        startServer()&#10;    }&#10;&#10;    private fun setupToolbar() {&#10;        binding.toolbar.title = &quot;TCP Server&quot;&#10;        binding.toolbar.subtitle = &quot;Listening on port $PORT&quot;&#10;    }&#10;&#10;    private fun setupChatAdapter() {&#10;        chatAdapter = ChatAdapter()&#10;        binding.chatRecyclerView.apply {&#10;            adapter = chatAdapter&#10;            layoutManager = LinearLayoutManager(this@ServerActivity)&#10;        }&#10;&#10;        // Thêm tin nhắn chào mừng&#10;        addSystemMessage(&quot;Server started on port $PORT&quot;)&#10;        addSystemMessage(&quot;Waiting for client connection...&quot;)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.sendButton.setOnClickListener {&#10;            sendMessage()&#10;        }&#10;&#10;        binding.messageInput.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEND) {&#10;                sendMessage()&#10;                true&#10;            } else {&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startServer() {&#10;        thread {&#10;            try {&#10;                Log.d(TAG, &quot;Starting server on port $PORT&quot;)&#10;                serverSocket = ServerSocket(PORT)&#10;                isRunning = true&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server listening on ${getLocalIpAddress()}:$PORT&quot;)&#10;                }&#10;&#10;                // Chờ client kết nối&#10;                clientSocket = serverSocket?.accept()&#10;                // Enable TCP keep-alive to maintain the connection&#10;                clientSocket?.soTimeout = 0 // disable read timeout if any&#10;                clientSocket?.keepAlive = true&#10;&#10;                Log.d(TAG, &quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client connected: ${clientSocket?.remoteSocketAddress}&quot;)&#10;                    binding.sendButton.isEnabled = true&#10;                    binding.messageInput.isEnabled = true&#10;                }&#10;&#10;                // Thiết lập input/output streams&#10;                outputStream = PrintWriter(clientSocket?.getOutputStream()!!, true)&#10;                inputStream = BufferedReader(InputStreamReader(clientSocket?.getInputStream()!!))&#10;&#10;                // Lắng nghe tin nhắn từ client&#10;                listenForMessages()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Server error: ${e.message}&quot;, e)&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Server error: ${e.message}&quot;)&#10;                    Toast.makeText(this@ServerActivity, &quot;Server error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun listenForMessages() {&#10;        thread {&#10;            try {&#10;                while (isRunning &amp;&amp; clientSocket?.isConnected == true) {&#10;                    val message = inputStream?.readLine()&#10;                    if (message != null) {&#10;                        Log.d(TAG, &quot;Received message: $message&quot;)&#10;                        runOnUiThread {&#10;                            chatAdapter.addMessage(ChatMessage(message, false, &quot;Client&quot;))&#10;                            scrollToBottom()&#10;                        }&#10;                    } else {&#10;                        // Client đã ngắt kết nối&#10;                        break&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error reading message: ${e.message}&quot;, e)&#10;            } finally {&#10;                runOnUiThread {&#10;                    addSystemMessage(&quot;Client disconnected&quot;)&#10;                    binding.sendButton.isEnabled = false&#10;                    binding.messageInput.isEnabled = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendMessage() {&#10;        val messageText = binding.messageInput.text.toString().trim()&#10;        if (messageText.isNotEmpty() &amp;&amp; outputStream != null) {&#10;            thread {&#10;                try {&#10;                    outputStream?.println(messageText)&#10;                    Log.d(TAG, &quot;Sent message: $messageText&quot;)&#10;&#10;                    runOnUiThread {&#10;                        chatAdapter.addMessage(ChatMessage(messageText, true, &quot;Server&quot;))&#10;                        binding.messageInput.text?.clear()&#10;                        scrollToBottom()&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error sending message: ${e.message}&quot;, e)&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@ServerActivity, &quot;Failed to send message&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun addSystemMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        chatAdapter.addMessage(ChatMessage(&quot;[$timestamp] $message&quot;, false, &quot;System&quot;))&#10;        scrollToBottom()&#10;    }&#10;&#10;    private fun scrollToBottom() {&#10;        binding.chatRecyclerView.scrollToPosition(chatAdapter.itemCount - 1)&#10;    }&#10;&#10;    private fun getLocalIpAddress(): String {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            while (interfaces.hasMoreElements()) {&#10;                val networkInterface = interfaces.nextElement()&#10;                val addresses = networkInterface.inetAddresses&#10;                while (addresses.hasMoreElements()) {&#10;                    val address = addresses.nextElement()&#10;                    if (!address.isLoopbackAddress &amp;&amp; address is Inet4Address) {&#10;                        return address.hostAddress ?: &quot;Unknown&quot;&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting IP address: ${e.message}&quot;, e)&#10;        }&#10;        return &quot;Unknown&quot;&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        cleanup()&#10;    }&#10;&#10;    private fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            inputStream?.close()&#10;            outputStream?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;            Log.d(TAG, &quot;Server cleanup completed&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during cleanup: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_client.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_client.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot;&#10;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&#10;            app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;!-- Connection Panel --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:background=&quot;?attr/colorSurface&quot;&#10;        android:elevation=&quot;2dp&quot;&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/serverIpInput&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:hint=&quot;Server IP Address (e.g. 192.168.1.100)&quot;&#10;            android:inputType=&quot;text&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot;&#10;            android:background=&quot;@android:drawable/edit_text&quot;&#10;            android:padding=&quot;12dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/connectButton&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Connect&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/chatRecyclerView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:clipToPadding=&quot;false&quot; /&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:background=&quot;?attr/colorSurface&quot;&#10;        android:elevation=&quot;4dp&quot;&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/messageInput&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:hint=&quot;@string/type_a_message&quot;&#10;            android:enabled=&quot;false&quot;&#10;            android:maxLines=&quot;3&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot;&#10;            android:background=&quot;@android:drawable/edit_text&quot;&#10;            android:padding=&quot;12dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/sendButton&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;@string/send&quot;&#10;            android:enabled=&quot;false&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;androidx.fragment.app.FragmentContainerView&#10;        android:id=&quot;@+id/nav_host_fragment&quot;&#10;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot;&#10;        app:defaultNavHost=&quot;true&quot;&#10;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&#10;        app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&#10;        android:id=&quot;@+id/bottom_navigation&quot;&#10;    &lt;com.google.android.material.bottomnavigation.BottomNavigationView&#10;        android:id=&quot;@+id/bottom_navigation&quot;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:gravity=&quot;center&quot;&#10;    android:padding=&quot;32dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;TCP Chat Application&quot;&#10;        android:textSize=&quot;24sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:textColor=&quot;?attr/colorPrimary&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Choose your role:&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:layout_marginBottom=&quot;32dp&quot;&#10;        android:gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/serverButton&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;60dp&quot;&#10;        android:text=&quot;Start as Server&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        style=&quot;@style/Widget.Material3.Button&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/clientButton&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;60dp&quot;&#10;        android:text=&quot;Start as Client&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:layout_marginBottom=&quot;32dp&quot;&#10;        style=&quot;@style/Widget.Material3.Button.OutlinedButton&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;• Server: Listens on port 5000\n• Client: Connects to server IP\n• Both devices must be on same WiFi&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:textColor=&quot;?android:attr/textColorSecondary&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:lineSpacingExtra=&quot;4dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_server.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_server.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&gt;&#10;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot;&#10;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&#10;            app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/chatRecyclerView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:clipToPadding=&quot;false&quot; /&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:padding=&quot;8dp&quot;&#10;        android:background=&quot;?attr/colorSurface&quot;&#10;        android:elevation=&quot;4dp&quot;&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/messageInput&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:hint=&quot;@string/type_a_message&quot;&#10;            android:enabled=&quot;false&quot;&#10;            android:maxLines=&quot;3&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot;&#10;            android:background=&quot;@android:drawable/edit_text&quot;&#10;            android:padding=&quot;12dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/sendButton&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;@string/send&quot;&#10;            android:enabled=&quot;false&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_message_received.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_message_received.xml" />
              <option name="originalContent" value="&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:paddingTop=&quot;4dp&quot;&#10;    android:paddingBottom=&quot;4dp&quot;&gt;&#10;&#10;    &lt;com.google.android.material.imageview.ShapeableImageView&#10;        android:id=&quot;@+id/avatarImageView&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:src=&quot;@drawable/ic_user_avatar&quot;&#10;        app:shapeAppearanceOverlay=&quot;@style/ShapeAppearanceOverlay.App.CornerSize50Percent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;/&gt;&#10;&#10;    &lt;com.google.android.material.card.MaterialCardView&#10;        android:id=&quot;@+id/messageCard&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:cardCornerRadius=&quot;16dp&quot;&#10;        app:cardBackgroundColor=&quot;?attr/colorSurfaceVariant&quot;&#10;        app:layout_constraintStart_toEndOf=&quot;@id/avatarImageView&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constrainedWidth=&quot;true&quot;&#10;        app:layout_constraintWidth_max=&quot;wrap&quot;&#10;        app:layout_constraintWidth_percent=&quot;0.7&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&gt;&#10;&#10;        &lt;LinearLayout&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;vertical&quot;&#10;            android:padding=&quot;12dp&quot;&gt;&#10;        android:layout_marginStart=&quot;8dp&quot;/&gt;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/senderTextView&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:textSize=&quot;12sp&quot;&#10;                android:textStyle=&quot;bold&quot;&#10;                android:textColor=&quot;?attr/colorOnSurfaceVariant&quot;&#10;                android:alpha=&quot;0.7&quot;&#10;                android:visibility=&quot;gone&quot; /&gt;&#10;            android:orientation=&quot;vertical&quot;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/messageTextView&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;Hello!&quot;&#10;                android:textColor=&quot;?attr/colorOnSurfaceVariant&quot;/&gt;&#10;                android:alpha=&quot;0.7&quot;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;&#10;                android:id=&quot;@+id/messageTextView&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;Hello!&quot;&#10;                android:textColor=&quot;?attr/colorOnSurfaceVariant&quot;/&gt;&#10;&#10;        &lt;/LinearLayout&gt;&#10;            &#10;    &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;horizontal&quot;&#10;    android:padding=&quot;8dp&quot;&#10;    android:gravity=&quot;start&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginEnd=&quot;64dp&quot;&#10;        android:background=&quot;#E0E0E0&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;12dp&quot;&#10;        android:layout_marginStart=&quot;8dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/senderText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Server&quot;&#10;            android:textColor=&quot;#666666&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:layout_marginBottom=&quot;2dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/messageText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Message text&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textSize=&quot;16sp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timeText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_gravity=&quot;start&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:text=&quot;12:30&quot;&#10;            android:textColor=&quot;#666666&quot;&#10;            android:textSize=&quot;12sp&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_message_sent.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_message_sent.xml" />
              <option name="originalContent" value="&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:paddingTop=&quot;4dp&quot;&#10;    android:paddingBottom=&quot;4dp&quot;&gt;&#10;&#10;    &lt;com.google.android.material.imageview.ShapeableImageView&#10;        android:id=&quot;@+id/avatarImageView&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:src=&quot;@drawable/ic_user_avatar&quot;&#10;        app:shapeAppearanceOverlay=&quot;@style/ShapeAppearanceOverlay.App.CornerSize50Percent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;/&gt;&#10;&#10;    &lt;com.google.android.material.card.MaterialCardView&#10;        android:id=&quot;@+id/messageCard&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:cardCornerRadius=&quot;16dp&quot;&#10;        app:cardBackgroundColor=&quot;?attr/colorPrimaryContainer&quot;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/avatarImageView&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constrainedWidth=&quot;true&quot;&#10;        app:layout_constraintWidth_max=&quot;wrap&quot;&#10;        app:layout_constraintWidth_percent=&quot;0.7&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&gt;&#10;&#10;        &lt;LinearLayout&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;vertical&quot;&#10;            android:padding=&quot;12dp&quot;&gt;&#10;        android:layout_marginEnd=&quot;8dp&quot;/&gt;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/senderTextView&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:textSize=&quot;12sp&quot;&#10;                android:textStyle=&quot;bold&quot;&#10;                android:textColor=&quot;?attr/colorOnPrimaryContainer&quot;&#10;                android:alpha=&quot;0.7&quot;&#10;                android:visibility=&quot;gone&quot; /&gt;&#10;        app:layout_constraintEnd_toStartOf=&quot;@id/avatarImageView&quot;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/messageTextView&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;Hi there!&quot;&#10;                android:textColor=&quot;?attr/colorOnPrimaryContainer&quot;/&gt;&#10;            android:padding=&quot;12dp&quot;&gt;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;            &lt;TextView&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:textSize=&quot;12sp&quot;&#10;                android:textStyle=&quot;bold&quot;&#10;                android:textColor=&quot;?attr/colorOnPrimaryContainer&quot;&#10;                android:alpha=&quot;0.7&quot;&#10;                android:visibility=&quot;gone&quot; /&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/messageTextView&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;Hi there!&quot;&#10;                android:textColor=&quot;?attr/colorOnPrimaryContainer&quot;/&gt;&#10;&#10;        &lt;/LinearLayout&gt;&#10;            &#10;    &lt;/com.google.android.material.card.MaterialCardView&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;horizontal&quot;&#10;    android:padding=&quot;8dp&quot;&#10;    android:gravity=&quot;end&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;64dp&quot;&#10;        android:background=&quot;#2196F3&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;12dp&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/messageText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Message text&quot;&#10;            android:textColor=&quot;@android:color/white&quot;&#10;            android:textSize=&quot;16sp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timeText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_gravity=&quot;end&quot;&#10;            android:layout_marginTop=&quot;4dp&quot;&#10;            android:text=&quot;12:30&quot;&#10;            android:textColor=&quot;@android:color/white&quot;&#10;            android:textSize=&quot;12sp&quot;&#10;            android:alpha=&quot;0.8&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>